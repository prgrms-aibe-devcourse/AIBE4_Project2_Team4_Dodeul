<!-- src/main/resources/templates/board/post-detail.html -->
<!doctype html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>ê²Œì‹œê¸€ ìƒì„¸</title>
  <link rel="stylesheet" href="/css/board/post-detail.css"/>
</head>
<body>
<main class="page">
  <section class="shell">
    <a class="back" href="/board/posts" aria-label="ëª©ë¡ìœ¼ë¡œ">
      <span class="back__icon">â†</span>
      <span class="back__text">ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°</span>
    </a>

    <article class="card">
      <header class="card__header">
        <div class="header__top">
          <span id="statusBadge" class="badge badge--gray">-</span>
          <div class="header__spacer"></div>

          <div class="header__actions">
            <button
              id="scrapBtn"
              class="iconbtn"
              type="button"
              aria-label="ìŠ¤í¬ë©"
              aria-pressed="false"
            >
              <span class="iconbtn__icon">ğŸ”–</span>
              <span id="scrapBtnCount" class="iconbtn__count">0</span>
            </button>

            <div class="kpi">
              <span class="kpi__item">
                <span class="kpi__icon">ğŸ‘</span>
                <span id="viewCount">0</span>
              </span>
            </div>
          </div>
        </div>

        <h1 id="title" class="title">ë¡œë”©ì¤‘...</h1>

        <div class="meta">
          <span class="meta__pill" id="authorPill">
            <span class="meta__label">ì‘ì„±ì</span>
            <span id="author" class="meta__value">-</span>
          </span>

          <span class="meta__pill" id="consultingPill">
            <span class="meta__label">ìƒë‹´ë¶„ì•¼</span>
            <span id="consulting" class="meta__value">-</span>
          </span>

          <span class="meta__date">
            <span id="createdAt">-</span>
            <span id="updatedAtWrap" class="meta__updated" style="display: none">
              Â· ìˆ˜ì • <span id="updatedAt">-</span>
            </span>
          </span>
        </div>

        <div class="tagrow">
          <div id="tagContainer" class="tags"></div>
          <div class="counts">
            <span class="counts__item">
              <span class="counts__label">ìŠ¤í¬ë©</span>
              <span id="scrapCount" class="counts__value">0</span>
            </span>
            <span class="counts__dot">Â·</span>
            <span class="counts__item">
              <span class="counts__label">ëŒ“ê¸€</span>
              <span id="commentCount" class="counts__value">0</span>
            </span>
          </div>
        </div>
      </header>

      <hr class="divider"/>

      <section class="content">
        <div id="content" class="content__body">-</div>
      </section>
    </article>

    <!-- ì²¨ë¶€íŒŒì¼ ì„¹ì…˜ -->
    <section class="attachments" id="attachmentsSection" style="display: none">
      <div class="attachments__head">
        <div class="attachments__title">ì²¨ë¶€íŒŒì¼</div>
        <div class="attachments__count" id="attachmentsCount">0</div>
      </div>

      <!-- íŒŒì¼ ì¹´ë“œ ë¦¬ìŠ¤íŠ¸ -->
      <div id="attachmentsList" class="attachments__list"></div>

      <!-- ë¯¸ë¦¬ë³´ê¸° ì˜ì—­(íŒŒì¼ íƒ€ì…ë³„ ë Œë”ë§) -->
      <div id="attachmentsPreview" style="display:none; margin-top: 12px;">
        <div style="display:flex; align-items:center; justify-content: space-between; gap: 8px; margin-bottom: 8px;">
          <div id="previewTitle" style="font-weight: 700;">ë¯¸ë¦¬ë³´ê¸°</div>
          <button id="previewCloseBtn" type="button" class="btn" style="padding:8px 12px;">ë‹«ê¸°</button>
        </div>
        <div id="previewBody"></div>
      </div>
    </section>

    <!-- ëŒ“ê¸€ ì„¹ì…˜ -->
    <div th:replace="~{board/post-comment :: postCommentSection}"></div>

    <input type="hidden" id="postId" th:value="${postId}"/>
  </section>
</main>
<script>
  (function () {
    const postIdEl = document.getElementById("postId");
    const postId = postIdEl ? postIdEl.value : "";

    const SUPABASE_PUBLIC_BASE = "https://dnpcfxbsyccwbfnmlaaq.supabase.co/storage/v1/object/public";
    const SUPABASE_BUCKET = "files";

    function pick(obj, path, fallback) {
      try {
        const v = path
          .split(".")
          .reduce((acc, key) => (acc == null ? null : acc[key]), obj);
        return v ?? fallback;
      } catch (e) {
        return fallback;
      }
    }

    function firstArrayValue(post, paths) {
      for (const p of paths) {
        const v = pick(post, p, null);
        if (Array.isArray(v)) return v;
      }
      return [];
    }

    function formatDate(value) {
      if (!value) return "-";
      const d = new Date(value);
      if (isNaN(d.getTime())) return String(value);
      const pad = (n) => String(n).padStart(2, "0");
      return (
        d.getFullYear() +
        "-" +
        pad(d.getMonth() + 1) +
        "-" +
        pad(d.getDate()) +
        " " +
        pad(d.getHours()) +
        ":" +
        pad(d.getMinutes())
      );
    }

    function setStatusBadge(status) {
      const el = document.getElementById("statusBadge");
      const s = String(status || "-").toUpperCase();

      el.classList.remove("badge--green", "badge--gray", "badge--red", "badge--blue");

      if (s === "OPEN") {
        el.classList.add("badge--blue");
        el.textContent = "OPEN";
        return;
      }
      if (s === "CLOSED") {
        el.classList.add("badge--gray");
        el.textContent = "CLOSED";
        return;
      }
      if (s === "DELETED") {
        el.classList.add("badge--red");
        el.textContent = "DELETED";
        return;
      }

      el.classList.add("badge--gray");
      el.textContent = s;
    }

    function renderTags(post) {
      const container = document.getElementById("tagContainer");
      if (!container) return;
      container.innerHTML = "";

      const list1 = pick(post, "skillTags", null);
      if (Array.isArray(list1) && list1.length > 0) {
        list1.forEach((t) => {
          const name = t && typeof t === "object" ? t.name ?? t.tagName ?? "" : String(t);
          if (!name) return;
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = name;
          container.appendChild(chip);
        });
        return;
      }

      const list2 = pick(post, "tags", null);
      if (Array.isArray(list2) && list2.length > 0) {
        list2.forEach((t) => {
          const name = t && typeof t === "object" ? t.name ?? "" : String(t);
          if (!name) return;
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.textContent = name;
          container.appendChild(chip);
        });
      }
    }

    function getExtFromName(name) {
      if (!name) return "";
      const i = String(name).lastIndexOf(".");
      return i >= 0 ? String(name).slice(i + 1).toLowerCase() : "";
    }

    function guessTypeByExt(ext) {
      if (!ext) return "";
      if (ext === "pdf") return "application/pdf";
      if (ext === "txt" || ext === "log" || ext === "md") return "text/plain";
      if (ext === "png") return "image/png";
      if (ext === "jpg" || ext === "jpeg") return "image/jpeg";
      if (ext === "gif") return "image/gif";
      if (ext === "webp") return "image/webp";
      return "";
    }

    function buildPublicUrlFromPath(path) {
      if (!path) return "";
      const p = String(path).replace(/^\/+/, "");
      if (p.startsWith("http://") || p.startsWith("https://")) return p;

      const normalized = p.startsWith(SUPABASE_BUCKET + "/")
        ? p.substring((SUPABASE_BUCKET + "/").length)
        : p;

      return SUPABASE_PUBLIC_BASE + "/" + SUPABASE_BUCKET + "/" + normalized;
    }

    function normalizeFile(a) {
      const obj = a && typeof a === "object" ? a : {};

      const rawUrl =
        obj.fileUrl ??
        obj.url ??
        obj.downloadUrl ??
        obj.publicUrl ??
        obj.presignedUrl ??
        obj.s3Url ??
        "";

      const rawPath =
        obj.path ??
        obj.filePath ??
        obj.storagePath ??
        obj.key ??
        obj.objectKey ??
        "";

      const fileName =
        obj.fileName ??
        obj.originFileName ??
        obj.originalName ??
        obj.name ??
        "ì²¨ë¶€íŒŒì¼";

      const contentTypeRaw = (obj.fileType ?? obj.contentType ?? obj.mimeType ?? "").toString();
      const ext = getExtFromName(fileName);
      const guessed = guessTypeByExt(ext);

      const fileUrl = rawUrl
        ? buildPublicUrlFromPath(rawUrl)
        : rawPath
          ? buildPublicUrlFromPath(rawPath)
          : "";

      const contentType = contentTypeRaw || guessed || "";

      const fileSizeRaw = obj.fileSize ?? obj.size ?? obj.bytes ?? null;
      const fileSize = fileSizeRaw == null ? null : Number(fileSizeRaw);

      return {
        fileUrl: String(fileUrl || ""),
        fileName: String(fileName || "ì²¨ë¶€íŒŒì¼"),
        contentType: String(contentType || ""),
        fileSize: Number.isFinite(fileSize) ? fileSize : null,
        ext: ext,
      };
    }

    function openPreview(file) {
      const wrap = document.getElementById("attachmentsPreview");
      const title = document.getElementById("previewTitle");
      const body = document.getElementById("previewBody");
      const closeBtn = document.getElementById("previewCloseBtn");
      if (!wrap || !title || !body || !closeBtn) return;

      title.textContent = "ë¯¸ë¦¬ë³´ê¸° Â· " + (file.fileName || "ì²¨ë¶€íŒŒì¼");
      body.innerHTML = "";
      wrap.style.display = "block";

      closeBtn.onclick = () => {
        wrap.style.display = "none";
        body.innerHTML = "";
      };

      const url = file.fileUrl;
      const type = (file.contentType || guessTypeByExt(file.ext) || "").toLowerCase();

      if (type.startsWith("image/")) {
        const img = document.createElement("img");
        img.src = url;
        img.alt = file.fileName || "ì²¨ë¶€íŒŒì¼";
        img.style.maxWidth = "100%";
        img.style.borderRadius = "12px";
        body.appendChild(img);
        return;
      }

      if (type === "application/pdf" || file.ext === "pdf") {
        const iframe = document.createElement("iframe");
        iframe.src = url;
        iframe.style.width = "100%";
        iframe.style.height = "640px";
        iframe.style.border = "0";
        iframe.style.borderRadius = "12px";
        body.appendChild(iframe);
        return;
      }

      if (type.startsWith("text/") || file.ext === "txt" || file.ext === "md" || file.ext === "log") {
        const pre = document.createElement("pre");
        pre.style.whiteSpace = "pre-wrap";
        pre.style.wordBreak = "break-word";
        pre.style.padding = "16px";
        pre.style.borderRadius = "12px";
        pre.style.border = "1px solid rgba(0,0,0,0.08)";
        pre.textContent = "ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...";
        body.appendChild(pre);

        fetch(url, {method: "GET"})
          .then((r) => (r.ok ? r.text() : Promise.reject(r)))
          .then((text) => {
            pre.textContent = text;
          })
          .catch(() => {
            pre.textContent = "í…ìŠ¤íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (ë‹¤ìš´ë¡œë“œë¡œ í™•ì¸í•´ì£¼ì„¸ìš”)";
          });
        return;
      }

      const p = document.createElement("div");
      p.style.padding = "12px 0";
      p.innerHTML = `
        <div style="margin-bottom:8px;">ë¸Œë¼ìš°ì €ì—ì„œ ë¯¸ë¦¬ë³´ê¸°ë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” í˜•ì‹ì…ë‹ˆë‹¤.</div>
        <a href="${url}" target="_blank" rel="noopener">íŒŒì¼ ì—´ê¸°/ë‹¤ìš´ë¡œë“œ</a>
      `;
      body.appendChild(p);
    }

    // âœ… ìˆ˜ì •: BoardPostFileResponse êµ¬ì¡°(files) + CommonResponse(data.files) ìš°ì„  ëŒ€ì‘
    function renderAttachments(payload) {
      const section = document.getElementById("attachmentsSection");
      const list = document.getElementById("attachmentsList");
      const countEl = document.getElementById("attachmentsCount");
      const previewWrap = document.getElementById("attachmentsPreview");
      const previewBody = document.getElementById("previewBody");
      if (!section || !list || !countEl) return;

      if (previewWrap && previewBody) {
        previewWrap.style.display = "none";
        previewBody.innerHTML = "";
      }

      const atts = firstArrayValue(payload, [
        "files",
        "data.files",
        "attachments",
        "commonFiles",
        "boardAttachments",
        "data.attachments",
        "data.commonFiles",
        "data.boardAttachments",
      ]).map(normalizeFile);

      const valid = atts.filter((x) => x.fileUrl);

      if (valid.length === 0) {
        section.style.display = "none";
        list.innerHTML = "";
        countEl.innerText = "0";
        return;
      }

      section.style.display = "block";
      countEl.innerText = String(valid.length);
      list.innerHTML = "";

      valid.forEach((a) => {
        const item = document.createElement("div");
        item.className = "attachcard";
        item.style.cursor = "pointer";

        const icon =
          (a.contentType && a.contentType.toLowerCase().startsWith("image/")) ||
          a.ext === "png" ||
          a.ext === "jpg" ||
          a.ext === "jpeg" ||
          a.ext === "gif" ||
          a.ext === "webp"
            ? "ğŸ–¼"
            : a.ext === "pdf"
              ? "ğŸ“•"
              : a.ext === "txt" || a.ext === "md" || a.ext === "log"
                ? "ğŸ“"
                : "ğŸ“„";

        const sizeLabel =
          a.fileSize == null
            ? ""
            : a.fileSize < 1024 * 1024
              ? Math.round(a.fileSize / 1024) + "KB"
              : (a.fileSize / (1024 * 1024)).toFixed(1) + "MB";

        const meta =
          (a.contentType ? a.contentType : "file") + (sizeLabel ? " Â· " + sizeLabel : "");

        item.innerHTML = `
          <div class="attachcard__icon">${icon}</div>
          <div class="attachcard__body">
            <div class="attachcard__name">${a.fileName}</div>
            <div class="attachcard__meta">${meta}</div>
          </div>
          <div class="attachcard__go">â†—</div>
        `;

        item.addEventListener("click", () => openPreview(a));

        item.querySelector(".attachcard__go")?.addEventListener("click", (e) => {
          e.stopPropagation();
          window.open(a.fileUrl, "_blank", "noopener");
        });

        list.appendChild(item);
      });
    }

    function getApiData(res) {
      if (res && res.data != null) return res.data;
      return res;
    }

    function findTokenFromStorage() {
      const candidates = [
        "accessToken",
        "ACCESS_TOKEN",
        "token",
        "jwt",
        "JWT",
        "Authorization",
        "authorization",
      ];
      for (const k of candidates) {
        const v1 = localStorage.getItem(k);
        if (v1) return v1;
        const v2 = sessionStorage.getItem(k);
        if (v2) return v2;
      }
      return null;
    }

    function buildAuthHeaders() {
      const headers = {};
      const raw = findTokenFromStorage();
      if (!raw) return headers;

      const token = String(raw).trim();
      if (!token) return headers;

      headers["Authorization"] = token.toLowerCase().startsWith("bearer ")
        ? token
        : "Bearer " + token;
      return headers;
    }

    function fetchJson(url, options) {
      const base = {
        credentials: "include",
        headers: {
          Accept: "application/json",
          ...(options && options.headers ? options.headers : {}),
        },
      };
      return fetch(url, {...base, ...(options || {})}).then((r) =>
        r.ok ? r.json() : Promise.reject(r)
      );
    }

    function closeAllMenus() {
      document.querySelectorAll(".comment__menu").forEach((m) => (m.style.display = "none"));
    }

    document.addEventListener("click", (e) => {
      const t = e.target;
      if (t && t.closest && t.closest(".comment__menuWrap")) {
        return;
      }
      closeAllMenus();
    });

    if (!postId) {
      document.getElementById("title").innerText = "ê²Œì‹œê¸€ IDê°€ ì—†ìŠµë‹ˆë‹¤.";
      return;
    }

    window.__POST_DETAIL__ = {
      postId: postId,
      postStatus: null,
      acceptedCommentId: null,
      scrappedByMe: false,
    };

    const submitBtn = document.getElementById("commentSubmitBtn");
    if (submitBtn) {
      submitBtn.addEventListener("click", () => createRootComment());
    }

    const scrapBtn = document.getElementById("scrapBtn");
    if (scrapBtn) {
      scrapBtn.addEventListener("click", () => toggleScrap());
    }

    function setScrapUi(scrapCount, scrappedByMe) {
      const cnt1 = document.getElementById("scrapCount");
      const cnt2 = document.getElementById("scrapBtnCount");
      const btn = document.getElementById("scrapBtn");

      if (cnt1) cnt1.innerText = String(scrapCount ?? 0);
      if (cnt2) cnt2.innerText = String(scrapCount ?? 0);

      window.__POST_DETAIL__.scrappedByMe = !!scrappedByMe;
      if (btn) {
        btn.setAttribute("aria-pressed", String(!!scrappedByMe));
        btn.classList.toggle("iconbtn--active", !!scrappedByMe);
      }
    }

    function toggleScrap() {
      const auth = buildAuthHeaders();
      if (!auth || !auth.Authorization) {
        alert("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
        return;
      }

      fetchJson("/api/board/posts/" + postId + "/scrap", {
        method: "POST",
        headers: {"Content-Type": "application/json", ...auth},
        body: JSON.stringify({}),
      })
        .then((res) => {
          const data = getApiData(res) || {};
          const nextCount =
            pick(data, "scrapCount", null) ??
            pick(data, "count", null) ??
            pick(data, "data.scrapCount", null);

          const nextScrapped =
            pick(data, "scrappedByMe", null) ??
            pick(data, "scrapped", null) ??
            pick(data, "data.scrappedByMe", null);

          const fallbackCount = Number(document.getElementById("scrapBtnCount")?.innerText || "0");
          const curr = !!window.__POST_DETAIL__.scrappedByMe;
          const toggled = !curr;

          setScrapUi(
            nextCount != null
              ? Number(nextCount)
              : toggled
                ? fallbackCount + 1
                : Math.max(0, fallbackCount - 1),
            nextScrapped != null ? !!nextScrapped : toggled
          );
        })
        .catch(() => alert("ìŠ¤í¬ë© ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."));
    }

    // âœ… 1) ê²Œì‹œê¸€ ìƒì„¸ + filesê°€ ìˆìœ¼ë©´ ì¦‰ì‹œ ë Œë”ë§
    fetchJson("/api/board/posts/" + postId, {headers: {...buildAuthHeaders()}})
      .then((res) => {
        const post = getApiData(res);

        if (!post) {
          document.getElementById("title").innerText = "ê²Œì‹œê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
          return;
        }

        document.getElementById("title").innerText = pick(post, "title", "-");
        document.getElementById("content").innerText = pick(post, "content", "-");

        // âœ… authorDisplayNameê¹Œì§€ íƒìƒ‰
        const authorName =
          pick(post, "author.nickname", null) ??
          pick(post, "author.displayName", null) ??
          pick(post, "authorName", null) ??
          pick(post, "authorNickname", null) ??
          pick(post, "authorDisplayName", null) ??
          pick(post, "nickname", null) ??
          "-";
        document.getElementById("author").innerText = authorName;

        const consultingObj =
          pick(post, "consultingTagSummary", null) ?? pick(post, "consultingTag", null);
        const consultingName =
          (consultingObj &&
            typeof consultingObj === "object" &&
            (consultingObj.name ?? consultingObj.code)) ||
          (typeof consultingObj === "string" ? consultingObj : "-");
        document.getElementById("consulting").innerText = consultingName;

        const status = pick(post, "postStatus", null) ?? pick(post, "status", "-");
        setStatusBadge(status);

        document.getElementById("viewCount").innerText = pick(post, "viewCount", 0);

        const scrapCount = pick(post, "scrapCount", 0);
        const scrappedByMe = !!pick(post, "scrappedByMe", false);
        setScrapUi(scrapCount, scrappedByMe);

        document.getElementById("commentCount").innerText = pick(post, "commentCount", 0);

        const createdAt = pick(post, "createdAt", null);
        document.getElementById("createdAt").innerText = formatDate(createdAt);

        const updatedAt = pick(post, "updatedAt", null);
        if (updatedAt) {
          document.getElementById("updatedAtWrap").style.display = "inline";
          document.getElementById("updatedAt").innerText = formatDate(updatedAt);
        }

        renderTags(post);
        window.__POST_DETAIL__.postStatus = String(status || "").toUpperCase();

        // âœ… ìƒì„¸ ì‘ë‹µì— filesê°€ ìˆìœ¼ë©´ ìš°ì„  ë Œë”ë§
        const filesInDetail = pick(post, "files", null);
        if (filesInDetail && Array.isArray(filesInDetail) && filesInDetail.length > 0) {
          renderAttachments({files: filesInDetail});
        }
      })
      // âœ… 2) ì²¨ë¶€íŒŒì¼ ì¡°íšŒ ì—”ë“œí¬ì¸íŠ¸ ë³€ê²½: /api/board/posts/{postId}/files
      .then(() =>
        fetchJson("/api/board/posts/" + postId + "/files", {
          headers: {...buildAuthHeaders()},
        })
          .then((res) => {
            console.log("Files API Response:", res);
            renderAttachments(getApiData(res));
          })
          .catch((err) => {
            console.error("Files API Error:", err);
            renderAttachments({files: []});
          })
      )
      .then(() => loadComments())
      .catch(() => {
        document.getElementById("title").innerText = "ìƒì„¸ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
      });

    function loadComments() {
      return fetchJson("/api/board/posts/" + postId + "/comments", {headers: {...buildAuthHeaders()}})
        .then((res) => {
          const data = getApiData(res);
          const acceptedId = pick(data, "acceptedCommentId", null);
          const roots = pick(data, "comments", []);

          window.__POST_DETAIL__.acceptedCommentId = acceptedId;
          renderComments(Array.isArray(roots) ? roots : [], acceptedId);
        })
        .catch(() => {
          const listEl = document.getElementById("commentList");
          if (listEl) listEl.innerHTML = "";
          const cnt = document.getElementById("answerCount");
          if (cnt) cnt.innerText = "0";
        });
    }

    function renderComments(rootComments, acceptedId) {
      const answerCountEl = document.getElementById("answerCount");
      if (answerCountEl) answerCountEl.innerText = String(rootComments.length);

      const listEl = document.getElementById("commentList");
      if (!listEl) return;
      listEl.innerHTML = "";

      rootComments.forEach((c) => {
        listEl.appendChild(renderCommentItem(c, acceptedId, true));

        const children = pick(c, "children", []);
        if (Array.isArray(children) && children.length > 0) {
          children.forEach((child) => {
            const childEl = renderCommentItem(child, acceptedId, false);
            childEl.style.marginLeft = "44px";
            listEl.appendChild(childEl);
          });
        }
      });
    }

    function renderCommentItem(c, acceptedId, isRoot) {
      const commentId = pick(c, "commentId", null) ?? pick(c, "id", null);
      const content = pick(c, "content", "");
      const createdAt = pick(c, "createdAt", null);

      const authorName =
        pick(c, "authorNickname", null) ??
        pick(c, "authorDisplayName", "-") ??
        pick(c, "authorNickname", "-");

      const roleTag = pick(c, "authorRoleTag", null);
      const likeCount = pick(c, "likeCount", 0);

      const canAccept = pick(c, "canAccept", false) === true;
      const canEdit = pick(c, "canEdit", false) === true;
      const canDelete = pick(c, "canDelete", false) === true;
      const canReply = pick(c, "canReply", false) === true;

      const isAccepted =
        pick(c, "accepted", null) === true ||
        (acceptedId != null && String(acceptedId) === String(commentId));

      const item = document.createElement("article");
      item.className = "comment";
      if (isAccepted) item.classList.add("comment--accepted");
      item.dataset.commentId = String(commentId || "");

      const header = document.createElement("div");
      header.className = "comment__head";

      const left = document.createElement("div");
      left.className = "comment__left";

      const avatar = document.createElement("div");
      avatar.className = "comment__avatar";
      avatar.textContent = authorName && authorName.length > 0 ? authorName[0] : "ğŸ‘¤";

      const meta = document.createElement("div");
      meta.className = "comment__meta";

      const top = document.createElement("div");
      top.className = "comment__topline";

      const name = document.createElement("span");
      name.className = "comment__name";
      name.textContent = authorName;

      const time = document.createElement("span");
      time.className = "comment__time";
      time.textContent = formatDate(createdAt);

      top.appendChild(name);

      if (roleTag) {
        const role = document.createElement("span");
        role.className = "comment__role";
        role.textContent = roleTag;
        top.appendChild(role);
      }

      top.appendChild(time);
      meta.appendChild(top);

      left.appendChild(avatar);
      left.appendChild(meta);

      const right = document.createElement("div");
      right.className = "comment__right";

      if (isAccepted) {
        const acceptedMark = document.createElement("span");
        acceptedMark.className = "comment__acceptedMark";
        acceptedMark.textContent = "âœ“ ì±„íƒë¨";
        right.appendChild(acceptedMark);
      }

      const likeBtn = document.createElement("button");
      likeBtn.className = "comment__iconBtn";
      likeBtn.type = "button";
      likeBtn.innerHTML = `<span class="comment__icon">â™¡</span><span class="comment__iconCount">${likeCount}</span>`;
      likeBtn.addEventListener("click", () => {
        fetchJson("/api/board/comments/" + commentId + "/likes/toggle", {
          method: "POST",
          headers: {...buildAuthHeaders()},
        })
          .then(() => loadComments())
          .catch(() => alert("ì¢‹ì•„ìš” ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."));
      });

      const menuWrap = document.createElement("div");
      menuWrap.className = "comment__menuWrap";

      const menuBtn = document.createElement("button");
      menuBtn.className = "comment__iconBtn";
      menuBtn.type = "button";
      menuBtn.innerHTML = `<span class="comment__icon">â‹®</span>`;
      menuBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const menu = menuWrap.querySelector(".comment__menu");
        const isOpen = menu && menu.style.display === "block";
        closeAllMenus();
        if (!menu) return;

        menu.style.display = isOpen ? "none" : "block";

        if (menu.style.display === "block") {
          menu.style.top = "40px";
          menu.style.bottom = "auto";
          const rect = menu.getBoundingClientRect();
          if (rect.bottom > window.innerHeight) {
            menu.style.top = "auto";
            menu.style.bottom = "40px";
          }
        }
      });

      const menu = document.createElement("div");
      menu.className = "comment__menu";
      menu.style.display = "none";

      const menuList = document.createElement("div");
      menuList.className = "comment__menuList";

      if (canEdit) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "comment__menuItem";
        b.textContent = "ìˆ˜ì •";
        b.addEventListener("click", () => {
          closeAllMenus();
          openEdit(item, commentId, content);
        });
        menuList.appendChild(b);
      }

      if (canDelete) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "comment__menuItem comment__menuItem--danger";
        b.textContent = "ì‚­ì œ";
        b.addEventListener("click", () => {
          closeAllMenus();
          deleteComment(commentId);
        });
        menuList.appendChild(b);
      }

      if (canReply) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "comment__menuItem";
        b.textContent = "ë‹µê¸€ ë‹¬ê¸°";
        b.addEventListener("click", () => {
          closeAllMenus();
          openReply(item, commentId);
        });
        menuList.appendChild(b);
      }

      if (menuList.childNodes.length === 0) {
        const empty = document.createElement("div");
        empty.className = "comment__menuEmpty";
        empty.textContent = "ê°€ëŠ¥í•œ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.";
        menu.appendChild(empty);
      } else {
        menu.appendChild(menuList);
      }

      menuWrap.appendChild(menuBtn);
      menuWrap.appendChild(menu);

      if (isRoot) {
        const acceptBtn = document.createElement("button");
        acceptBtn.className = "btn btn--accept";
        acceptBtn.type = "button";
        acceptBtn.textContent = "ì±„íƒí•˜ê¸°";

        if (!canAccept) {
          acceptBtn.style.display = "none";
        } else {
          acceptBtn.addEventListener("click", () => acceptComment(commentId));
        }
        right.appendChild(acceptBtn);
      }

      right.appendChild(likeBtn);
      right.appendChild(menuWrap);

      header.appendChild(left);
      header.appendChild(right);

      const body = document.createElement("div");
      body.className = "comment__body";
      body.textContent = content;

      item.appendChild(header);
      item.appendChild(body);

      return item;
    }

    function openEdit(commentEl, commentId, currentContent) {
      const body = commentEl.querySelector(".comment__body");
      if (!body) return;
      if (commentEl.querySelector(".comment__editor")) return;

      const editor = document.createElement("div");
      editor.className = "comment__editor";

      const ta = document.createElement("textarea");
      ta.className = "comment__editorInput";
      ta.value = currentContent || "";
      editor.appendChild(ta);

      const actions = document.createElement("div");
      actions.className = "comment__editorActions";

      const cancel = document.createElement("button");
      cancel.type = "button";
      cancel.className = "btn";
      cancel.textContent = "ì·¨ì†Œ";
      cancel.addEventListener("click", () => {
        editor.remove();
        body.style.display = "";
      });

      const save = document.createElement("button");
      save.type = "button";
      save.className = "btn btn--primary";
      save.textContent = "ìˆ˜ì •";
      save.addEventListener("click", () => {
        const next = String(ta.value || "").trim();
        if (!next) {
          alert("ë‚´ìš©ì€ ê³µë°±ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        fetchJson("/api/board/comments/" + commentId, {
          method: "PATCH",
          headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
          body: JSON.stringify({content: next}),
        })
          .then(() => loadComments())
          .catch(() => alert("ëŒ“ê¸€ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."));
      });

      actions.appendChild(cancel);
      actions.appendChild(save);
      editor.appendChild(actions);

      body.style.display = "none";
      commentEl.appendChild(editor);
    }

    function openReply(commentEl, parentCommentId) {
      if (commentEl.querySelector(".comment__reply")) return;

      const reply = document.createElement("div");
      reply.className = "comment__reply";

      const ta = document.createElement("textarea");
      ta.className = "comment__replyInput";
      ta.placeholder = "ë‹µê¸€ì„ ì…ë ¥í•˜ì„¸ìš”...";
      reply.appendChild(ta);

      const actions = document.createElement("div");
      actions.className = "comment__replyActions";

      const cancel = document.createElement("button");
      cancel.type = "button";
      cancel.className = "btn";
      cancel.textContent = "ì·¨ì†Œ";
      cancel.addEventListener("click", () => reply.remove());

      const submit = document.createElement("button");
      submit.type = "button";
      submit.className = "btn btn--primary";
      submit.textContent = "ë‹µê¸€ ì‘ì„±";
      submit.addEventListener("click", () => {
        const content = String(ta.value || "").trim();
        if (!content) {
          alert("ë‚´ìš©ì€ ê³µë°±ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        fetchJson("/api/board/posts/" + postId + "/comments", {
          method: "POST",
          headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
          body: JSON.stringify({content: content, parentCommentId: parentCommentId}),
        })
          .then(() => loadComments())
          .catch(() => alert("ë‹µê¸€ ì‘ì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."));
      });

      actions.appendChild(cancel);
      actions.appendChild(submit);
      reply.appendChild(actions);

      commentEl.appendChild(reply);
      ta.focus();
    }

    function deleteComment(commentId) {
      if (!confirm("ëŒ“ê¸€ì„ ì‚­ì œí• ê¹Œìš”?")) return;

      fetchJson("/api/board/comments/" + commentId, {
        method: "DELETE",
        headers: {...buildAuthHeaders()},
      })
        .then(() => loadComments())
        .catch(() => alert("ëŒ“ê¸€ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."));
    }

    function createRootComment() {
      const textarea = document.getElementById("commentContent");
      if (!textarea) return;

      const content = String(textarea.value || "").trim();
      if (!content) {
        alert("ë‚´ìš©ì€ ê³µë°±ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
      }

      fetchJson("/api/board/posts/" + postId + "/comments", {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({content: content, parentCommentId: null}),
      })
        .then(() => {
          textarea.value = "";
          return loadComments();
        })
        .catch(() => alert("ëŒ“ê¸€ ì‘ì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."));
    }

    function acceptComment(commentId) {
      if (!commentId) return;

      fetchJson("/api/board/posts/" + postId + "/accept", {
        method: "PATCH",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({commentId: commentId}),
      })
        .then((res) => {
          const data = getApiData(res);

          window.__POST_DETAIL__.postStatus = "CLOSED";
          window.__POST_DETAIL__.acceptedCommentId =
            data && data.acceptedCommentId != null ? data.acceptedCommentId : commentId;

          setStatusBadge("CLOSED");
          return loadComments();
        })
        .catch(() => alert("ì±„íƒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."));
    }
  })();
</script>
</body>
</html>
